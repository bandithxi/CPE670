//#ifndef __CLAWAPI_NXC__
//#define __CLAWAPI_NXC__

/**
 * Claw Configurations
 */
//#define CLAW_MOTOR OUT_B

//#define CLAW_POWER 35
//#define CLAW_INCREMENT_TIME MS_50

//enum ClawPosition {
//  CLAW_DOWN = 0, // on the ground
//  CLAW_LOW = 1,  //    |
//  CLAW_HIGH = 2, //    v
//  CLAW_UP = 3    // fully raised
//};


/**
 * Claw State variables
 */
//int gClawPosition = 0;


/**
 * Simply lowers the claw all the way to the ground to establish an initial
 * position, then raises it to prepare for action.
 */
//void initializeClaw();

/**
 *
 */
//void moveClawToPosition(int pPosition);

/**
 *
 */
//void testClawAPI();

/*
void initializeClaw() {
    // lower the claw ``past" what should be the bottom (DOWN) for good measure
    OnRev(CLAW_MOTOR, CLAW_POWER);
    for (int i = 0; i < 4; i++) {
        Wait(CLAW_INCREMENT_TIME);
    }
    gClawPosition = 0;

    moveClawToPosition(UP);
}


void moveClawToPosition(int pPosition) {
  if (pPosition < DOWN || UP < pPosition) {
    pPosition = UP;
  }

  int unitsToMove = pPosition - gClawPosition;
  
  if (unitsToMove > 0) {
    OnFwd(CLAW_MOTOR, CLAW_POWER);
  } else if (unitsToMove < 0) {
//    unitsToMove ^= 0x8000;  // 0b 1000 0000 0000 0000 to flip the sign
    OnRev(CLAW_MOTOR, CLAW_POWER);
  }

  for(int i = 0; i < unitsToMove; i++) {
    Wait(CLAW_INCREMENT_TIME);
  }
  Off(CLAW_MOTOR);
}


void testClawAPI() {
     initializeClaw();
     moveClawToPosition(CLAW_LOW);
     moveClawToPosition(CLAW_HIGH);
     moveClawToPosition(CLAW_DOWN);
     moveClawToPosition(CLAW_UP);
}

*/
//#endif //__CLAWAPI_NXC__
