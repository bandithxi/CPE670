#ifndef __LAB06_CONTROLLER_NXC__
#define __LAB06_CONTROLLER_NXC__

#include "ControllerConfigurations.nxc"

#include "Utilities.nxc"
#include "DrivingAPI.nxc"
//#inlcude "ClawAPI.nxc"
#include "SonarSensing.nxc"
#include "ColorSensing.nxc"
#include "LightSensing.nxc"
#include "CompassSensing.nxc"
#include "TouchSensing.nxc"


#define ORIENTATION_TOLERANCE 2 // degrees(ish))
#define WALL_PROXIMITY 22       // cm(ish)

/**
 * An enumeration of control strategy values.
 */
enum Strategies {
  PROCEED,
  U_TURN,
  FIND_ENDZONE,
  ALIGN_SELF,
  CREEP_UP_TO_BALL,
  DUMP_RED_BALL,
  DUMP_BLUE_BALL
};


/**
 * Spawns the thread responsible for initializing the robot.
 */
task main();

/**
 * 
 */
task TASK_controller();


/**
 * Drives the robot to the NW corner of the arena, ideally aligning it for
 * ball capture.
 */
void goToBallAreaStartCorner();
void alignForBallPickup();
void findBall();
int captureBall();
void dumpBallInBallArea();
void dumpBallInFarArea();
void dumpBall(int pHeading);
void orientSelf(const int pHeading);
void driveUpToWall(const bool pWallIsEndzone);

task main() {
  Precedes(
    TASK_ColorSensing,
    TASK_CompassSensing,
    TASK_LightSensing,
    TASK_SonarSensing,
    TASK_TouchSensing,
    TASK_controller
  );

  initializeMUX(MUX_PORT);
  initializeClaw();
  Wait(MS_500);
  
//  testMovementLib();
//  testClawAPI();
}


task TASK_controller() {

  #if 0
    gUseLightSensing = true;
    int i  = 0;
    while (true) {
      // this let's us know that the robot is processing things
      TextOut(2, LCD_LINE7, "TESTING SHIT");
      NumOut(6, LCD_LINE8, i++);
      // sensor debug output should be concurrently printing
    }
    gUseLightSensing = false;
  #endif

  int strategy;

  while (true) { // we will stop the contest after 2 minutes
    goToBallAreaStartCorner();
    alignForBallPickup();
    findBall();
    strategy = captureBall();

    if (strategy == DUMP_RED_BALL) {
      dumpBallInBallArea();
   } else if (strategy == DUMP_BLUE_BALL) {
      dumpBallInFarArea();
   }
      // TODO: otherwise go to middle? break?
  }

  StopAllTasks();
}


int determineStrategy(int pLastStrategy) {

}


void goToBallAreaStartCorner() {
  orientSelf(ARENA_NORTH);

  driveUpToWall(false);
  orientSelf(ARENA_EAST);

  // get up in that corner
  driveUpToWall(true);
  orientSelf(ARENA_SE);
  moveSetDistance(FORWARD, 2);
  orientSelf(ARENA_SOUTH);
  
}


void alignForBallPickup() {
  orientSelf(ARENA_SOUTH - 5); // TODO: maybe refine this
}



void findBall() {
  gUseColorSensing = true;

  startDrivingStraight(FORWARD, CRAWL_SPEED);
  until(gColorReading.value.colorNum != 0);
  
  gUseColorSensing = false;
}


int captureBall() {
  moveClawToPosition(CLAW_DOWN);

  orientSelf(ARENA_SE);
  moveSetDistance(REVERSE, 4);

  gUseColorSensing = true;
  Wait(MS_50);
   
  int strategy = DUMP_RED_BALL;
  if (gColorReading.value.colorNum == BLUE_BALL_COLOR) {
    strategy = DUMP_BLUE_BALL;
  } else if (gColorReading.value.colorNum == RED_BALL_COLOR) {
    strategy = DUMP_RED_BALL;
  }
   
  return strategy;
}


void dumpBallInBallArea() {
  orientSelf(ARENA_EAST);
  dumpBall();
}


void dumpBallInFarArea() {
  orientSelf(ARENA_WEST);
  driveUpToWall(true);
  dumpBall();
}

void dumpBall(int pHeading) {
  gUseTouchSensing = true;
  startDrivingStraight(FORWARD, CRAWL_SPEED);
  until(gTouchReading.value == 1);
  gUseTouchSensing = false;

  moveSetDistance(REVERSE, 1);
  orientSelf(pHeading);

  moveClawToPosition(CLAW_LOW);
  moveClawToPosition(CLAW_UP);
  holdClawUp();
  moveSetDistance(FORWARD, 4);
  
  moveSetDistance(REVERSE, 10);
}


void orientSelf(const int pHeading) {
  gUseCompassSensing = true;
  bool aboveThreshold = false;
  bool belowThreshold = false;

  int currentHeading = gCompassReading.value;
  if (currentHeading - pHeading > ORIENTATION_TOLERANCE) {
    startStationarySpin(LEFT);
  } else if (currentHeading - pHeading < -1 *ORIENTATION_TOLERANCE) {
    startStationarySpin(RIGHT);
  }

  // if we are already at the correct heading, the robot won't be moving.
  // this would honestly be more readable with a do-while, but I am
  // principally against do-whiles
  while (!(aboveThreshold && belowThreshold)) {
    aboveThreshold =
      (pHeading - ORIENTATION_TOLERANCE) <= gCompassReading.value;
    belowThreshold =
      gCompassReading.value <= (pHeading + ORIENTATION_TOLERANCE);
  }
  
  stopWheels();
  gUseCompassSensing = false;
}


void driveUpToWall(const bool pWallIsEndzone) {
  gUseSonarSensing = true;
  if (pWallIsEndzone) {
    gUseLightSensing = true;
  }
  Wait(MS_50);
  
  bool stopDriving = false;
  while (!stopDriving) {
  startDrivingStraight(FORWARD, CRUISE_SPEED);
    until(
//      gSonarReading.rightValue <= WALL_PROXIMITY ||
      gSonarReading.leftValue <= WALL_PROXIMITY
    );
    
    if (gUseLightSensing) {
      if (gLightReading.rightValue <= MUXED_BLACK_UPPER) {
        stopDriving = true;
      }
    } else {
      stopDriving = true;
    }
  }
  stopWheels();
  
  moveSetDistance(REVERSE, 2);
  
  gUseSonarSensing = false;
  gUseLightSensing = false;
}

#endif //__LAB06_CONTROLLER_NXC__
