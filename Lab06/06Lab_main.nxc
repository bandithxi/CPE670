#ifndef __LAB06_CONTROLLER_NXC__
#define __LAB06_CONTROLLER_NXC__

#include "ControllerConfigurations.nxc"

#include "Utilities.nxc"
#include "DrivingAPI.nxc"
//#inlcude "ClawAPI.nxc" // TODO: why won't having a separate file work?
#include "SonarSensing.nxc"
#include "ColorSensing.nxc"
#include "LightSensing.nxc"
#include "CompassSensing.nxc"
#include "TouchSensing.nxc"

/**
 * Some constants specific to this particular controller program. For more
 * "universal" constant definitions, see 'ControllerConfigurations.nxc'.
 */
#define ORIENTATION_TOLERANCE 2 // degrees(ish))
#define WALL_PROXIMITY 22       // cm(ish)
#define ENDZONE_WALL true
#define NORMAL_WALL false

/**
 * An enumeration of control strategy values.
 */
enum Strategies {
  PROCEED,
  U_TURN,
  GO_TO_WALL,
  GO_TO_BALL_AREA,
  TURN_TO_BALL_AREA,
  ALIGN_FOR_BALL_PICKUP,
  CREEP_UP_TO_BALL,
  CAPTURE_BALL,
  DUMP_RED_BALL,
  DUMP_BLUE_BALL,
  GO_TO_MIDDLE
};


/**
 * Spawns the thread responsible for initializing the robot.
 */
task main();

/**
 * The main controlling task. Controls the robot to achieve the goal of
 * finding colored balls, capturing them, and depositing them over the
 * correct edge of the arena. 
 */
task TASK_controller();

/**
 * 
 */
int determineStrategy(int pLastStrategy);

/**
 *
 */
int driveTowardsWall(const int pWallHeading, const int pLastStrategy);
int backUpAndTurn(const int pStrategy);
void alignForBallPickup();
int creepUpToBall();
int captureBall();
void dumpBallInBallArea();
void dumpBallInFarArea();
void dumpBall(int pHeading);
bool ballObserved();
bool wallObserved();
bool blackFloorObserved();
void orientSelf(const int pHeading);


task main() {
  Precedes(
    TASK_ColorSensing,
    TASK_CompassSensing,
    TASK_LightSensing,
    TASK_SonarSensing,
    TASK_TouchSensing,
    TASK_controller
  );

  initializeMUX(MUX_PORT);
  initializeClaw();
  Wait(MS_50);
  
//  testMovementLib();
//  testClawAPI();
}


task TASK_controller() {

  #if 0
    gUseLightSensing = true;
    int i  = 0;
    while (true) {
      // this let's us know that the robot is processing things
      TextOut(2, LCD_LINE7, "TESTING SHIT");
      NumOut(6, LCD_LINE8, i++);
      // sensor debug output should be concurrently printing
    }
    gUseLightSensing = false;
  #endif

  int strategy = GO_TO_WALL;

  while (true) { // we will stop the contest after 2 minutes
    switch (strategy) {
      case GO_TO_WALL:
        strategy = driveTowardsWall(ARENA_NORTH, strategy);
        break;
      case GO_TO_BALL_AREA:
        strategy = driveTowardsWall(ARENA_EAST, strategy);
        break;
      case TURN_TO_BALL_AREA:
        backUpAndTurn(strategy);
        break;
      case ALIGN_FOR_BALL_PICKUP:
        alignForBallPickup();
        break;
      case CREEP_UP_TO_BALL:
        strategy = creepUpToBall();
        break;
      case CAPTURE_BALL:
        strategy = captureBall();
        break;
      case DUMP_RED_BALL:
        strategy = dumpBallInBallArea();
        break;
      case DUMP_BLUE_BALL:
        strategy = dumpBallInFarArea();
        break;
      case GO_TO_MIDDLE:
        backUpAndTurn(GO_TO_MIDDLE);
      default:
        break;
    }
    strategy = determineStrategy(strategy);
  }

  StopAllTasks();
}


int
determineStrategy(int pLastStrategy) {
  int strategy;

  if (pLastStrategy != DUMP_BLUE_BALL && != DUMP_RED_BALL) {
    gUseSonarSensing = true;
    gUseColorSensing = true;
    gUseLightSensing = true;
    Wait(MS_50);

    bool ballPresent = ballObserved();
    bool wallPresent = wallObserved();
    bool onTheBlack = blackFloorObserved();

    gUseSonarSensing = false;
    gUseColorSensing = false;
    gUseLightSensing = false;

    if (ballPresent) {
      strategy = CAPTURE_BALL;
    } else if (wallPresent) {
      switch (pLastStrategy) {
        case GO_TO_WALL:
          strategy = TURN_TO_BALL_AREA;
          break;
        case GO_TO_BALL_AREA:
          if (onTheBlack) {
            strategy = ALIGN_FOR_BALL_PICKUP;
          } else {
            strategy = GO_TO_BALL_AREA;
          }
        default:
          strategy = GO_TO_MIDDLE;
          break;
      }  
  } else {
    strategy = pLastStrategy;
  }

  return strategy;
}


int
driveTowardsWall(const int pWallHeading, const int pLastStrategy) {
  orientSelf(pWallHeading);
  moveSetDistance(FORWARD, 4);
  stopWheels();

  return pLastStrategy;
}

int
backUpAndTurn(const int pStrategy) {
  moveSetDistance(REVERSE, 2);

  int heading;
  int strategy = pStrategy;
  switch (pStrategy) {
    case TURN_TO_BALL_AREA:
      heading = ARENA_EAST;
      strategy = GO_TO_BALL_AREA;
      break;
    case GO_TO_MIDDLE:
    default:
      heading = ARENA_NORTH;
      strategy = GO_TO_MIDDLE;
      break;
  }
  orientSelf(heading);

  return strategy;
} 

void
alignForBallPickup() {
  // get up in that corner
  orientSelf(ARENA_SE);
  moveSetDistance(FORWARD, 2);
  orientSelf(ARENA_SOUTH - 5); // TODO: maybe refine this
}

int
creepUpToBall() {
  gUseColorSensing = true;
  gUseSonarSensing = true;

  int strategy = CREEP_UP_TO_BALL;

  startDrivingStraight(FORWARD, CRAWL_SPEED);
  until (ballObserved() || wallObserved());      // TODO: reconsider using sonar

  if (wallObserved()) {
    strategy = GO_TO_MIDDLE;
  } else {
    strategy = CAPTURE_BALL;
  }

  gUseColorSensing = false;
  gUseSonarSensing = false;

  return strategy;
}

int
captureBall() {
  moveClawToPosition(CLAW_DOWN);

  gUseColorSensing = true;

  orientSelf(ARENA_SE);
  moveSetDistance(REVERSE, 4);

   
  int strategy = GO_TO_MIDDLE;
  if (gColorReading.value.colorNum == BLUE_BALL_COLOR) {
    strategy = DUMP_BLUE_BALL;
  } else if (gColorReading.value.colorNum == RED_BALL_COLOR) {
    strategy = DUMP_RED_BALL;
  }

  gUseColorSensing = false;
   
  return strategy;
}


void
dumpBallInBallArea() {
  orientSelf(ARENA_EAST);
  dumpBall();
}


void
dumpBallInFarArea() {
  orientSelf(ARENA_WEST);

  gUseSonarSensing = true;
  gUseLightSensing = true;
  startDrivingStraight(CRUISE_SPEED);
  until (
    wallObserved() &&
    gLightReading.rightValue <= BLACK_LIGHT_UPPER_THRESHOLD
  );
  gUseSonarSensing = false;
  gUseLightSensing = false;

  dumpBall();
}

void
dumpBall(int pHeading) {
  gUseTouchSensing = true;
  startDrivingStraight(FORWARD, CRAWL_SPEED);
  until(gTouchReading.value == 1);
  gUseTouchSensing = false;

  moveSetDistance(REVERSE, 1);
  orientSelf(pHeading);

  moveClawToPosition(CLAW_LOW);
  moveClawToPosition(CLAW_UP);
  holdClawUp();
  moveSetDistance(FORWARD, 4);
  
  moveSetDistance(REVERSE, 10);
}

bool
ballObserved() {
  return (
    gColorReading.value.colorNum == BLUE_BALL_COLOR || 
    gColorReading.value.colorNum == RED_BALL_COLOR
  );
}

bool wallObserved() {
  return gSonarReading.leftValue <= WALL_PROXIMITY;
}

bool blackFloorObserved() {
  return gLightReading.rightValue <= BLACK_LIGHT_UPPER_THRESHOLD;
}

void
orientSelf(const int pHeading) {
  gUseCompassSensing = true;
  bool aboveThreshold = false;
  bool belowThreshold = false;

  int currentHeading = gCompassReading.value;
  if (currentHeading - pHeading > ORIENTATION_TOLERANCE) {
    startStationarySpin(LEFT);
  } else if (currentHeading - pHeading < -1 *ORIENTATION_TOLERANCE) {
    startStationarySpin(RIGHT);
  }

  // if we are already at the correct heading, the robot won't be moving.
  // this would honestly be more readable with a do-while, but I am
  // principally against do-whiles
  while (!(aboveThreshold && belowThreshold)) {
    aboveThreshold =
      (pHeading - ORIENTATION_TOLERANCE) <= gCompassReading.value;
    belowThreshold =
      gCompassReading.value <= (pHeading + ORIENTATION_TOLERANCE);
  }
  
  stopWheels();
  gUseCompassSensing = false;
}

#endif //__LAB06_CONTROLLER_NXC__
