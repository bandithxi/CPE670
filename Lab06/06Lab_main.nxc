#ifndef __LAB06_CONTROLLER_NXC__
#define __LAB06_CONTROLLER_NXC__

#include "ControllerConfigurations.nxc"

#include "Utilities.nxc"
#include "DrivingAPI.nxc"
//#inlcude "ClawAPI.nxc"
#include "SonarSensing.nxc"
#include "ColorSensing.nxc"
#include "LightSensing.nxc"
#include "CompassSensing.nxc"
#include "TouchSensing.nxc"


#define ORIENTATION_TOLERANCE 2 // degrees(ish))
#define WALL_PROXIMITY 22       // cm(ish)

/**
 * An enumeration of control strategy values.
 */
enum Strategies {
  PROCEED,
  U_TURN,
  FIND_ENDZONE,
  ALIGN_SELF,
  CREEP_UP_TO_BALL,
  DUMP_RED_BALL,
  DUMP_BLUE_BALL
};


/**
 * Spawns the thread responsible for initializing the robot.
 */
task main();

/**
 * 
 */
task TASK_controller();


void goToBallAreaStartCorner();
void orientSelf(const int pHeading);
void driveUpToWall(const bool pWallIsEndzone);
void alignForBallPickup();
void findBall();
int captureBall();
void dumpBallInBallArea();
void dumpBallInFarArea();
void dumpBall();


task main() {
  Precedes(
    TASK_ColorSensing,
    TASK_CompassSensing,
    TASK_LightSensing,
    TASK_SonarSensing,
    TASK_TouchSensing,
    TASK_controller
  );

  initializeMUX(MUX_PORT);
  initializeClaw();
  Wait(MS_500);
  
//  testMovementLib();
//  testClawAPI();
}


task TASK_controller() {
  bool testStuff = false;
  gUseLightSensing = true;
  int i  = 0;
  while (testStuff) {
    TextOut(2, LCD_LINE7, "TESTING SHIT");
    NumOut(6, LCD_LINE8, i++);
  }
  gUseLightSensing = false;

  int strategy;

  while (true) { // no stopping condition for contest given
    goToBallAreaStartCorner();
    alignForBallPickup();
    findBall();
    strategy = captureBall();

    if (strategy == DUMP_RED_BALL) {
      dumpBallInBallArea();
   } else if (strategy == DUMP_BLUE_BALL) {
      dumpBallInFarArea();
   }
      // TODO: otherwise go to middle? break?
  }

  StopAllTasks();
}


void goToBallAreaStartCorner() {
  orientSelf(ARENA_NORTH);

  driveUpToWall(false);
  stationaryTurn(LEFT, TURN_90);

  driveUpToWall(true);
  stationaryTurn(LEFT, TURN_90);
  
  gUseCompassSensing = false;
}


void orientSelf(const int pHeading) {
  gUseCompassSensing = true;
  bool aboveThreshold = false;
  bool belowThreshold = false;
  startStationarySpin(RIGHT);

  while (!(aboveThreshold && belowThreshold)) {
    aboveThreshold =
      (pHeading - ORIENTATION_TOLERANCE) <= gCompassReading.value;
    belowThreshold =
      gCompassReading.value <= (pHeading + ORIENTATION_TOLERANCE);
  }
  
  stopWheels();
  gUseCompassSensing = false;
}


void driveUpToWall(const bool pWallIsEndzone) {
  gUseSonarSensing = true;
  if (pWallIsEndzone) {
    gUseLightSensing = true;
  }
  Wait(MS_50);
  
  bool stopDriving = false;
  while (!stopDriving) {
  startDrivingStraight(FORWARD, CRUISE_SPEED);
    until(
//      gSonarReading.rightValue <= WALL_PROXIMITY ||
      gSonarReading.leftValue <= WALL_PROXIMITY
    );
    
    if (gUseLightSensing) {
      if (gLightReading.rightValue <= MUXED_BLACK_UPPER) {
        stopDriving = true;
      }
    } else {
      stopDriving = true;
    }
  }
  stopWheels();
  
  moveSetDistance(REVERSE, 2);
  
  gUseSonarSensing = false;
  gUseLightSensing = false;
}


void alignForBallPickup() {
  orientSelf(ARENA_SOUTH);
}



void findBall() {
  gUseColorSensing = true;

  startDrivingStraight(FORWARD, CRAWL_SPEED);
  until(gColorReading.value.colorNum != 0);
  
  gUseColorSensing = false;
}


int captureBall() {
  moveClawToPosition(CLAW_DOWN);
   
  gUseColorSensing = true;
  Wait(MS_50);
   
  int strategy = DUMP_RED_BALL;
  if (gColorReading.value.colorNum == BLUE_BALL_COLOR) {
    strategy = DUMP_BLUE_BALL;
  } else if (gColorReading.value.colorNum == RED_BALL_COLOR) {
    strategy = DUMP_RED_BALL;
  }
   
  return strategy;
}


void dumpBallInBallArea() {
  orientSelf(ARENA_EAST);
  dumpBall();
}


void dumpBallInFarArea() {
  orientSelf(ARENA_WEST);
  driveUpToWall(true);
  dumpBall();
}

void dumpBall() {
  gUseTouchSensing = true;
  startDrivingStraight(FORWARD, CRAWL_SPEED);
  until(gTouchReading.value == 1);

  moveSetDistance(REVERSE, 1);
  gUseTouchSensing = false;

  moveClawToPosition(CLAW_LOW);
  moveClawToPosition(CLAW_UP);
  holdClawUp();
  moveSetDistance(FORWARD, 4);
  
  moveSetDistance(REVERSE, 10);
}


#endif //__LAB06_CONTROLLER_NXC__
