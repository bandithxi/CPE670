#ifndef __COLORSENSING_NXC__
#define __COLORSENSING_NXC__

#define COLOR_SENSOR IN_3

#define HOME_COLOR 0
#define LINE_COLOR 0
#define END_OF_LINE_COLOR 7
#define FEILD_COLOR 13


// we might be able to use RGB values to somehow compensate for poor
// color number results
typedef struct {
  byte colorNum;
  byte red;
  byte green;
  byte blue;
} ColorVal;


typedef struct {
  ColorVal value;
  mutex ownership;
  bool readingIsValid;
} ColorReading;


bool gUseColorSensing = true;
ColorReading gColorReading;

task TASK_colorSensing();
void debugOutputColor(const ColorVal& pColorVal);
bool readingIsValid(const ColorVal& pColorVal);


/**
 *  This thread continually reads the color sensor value
 */
task TASK_colorSensing() {
  SetSensorLowspeed(COLOR_SENSOR);

  gColorReading.readingIsValid = false;

  while (gUseColorSensor) {
    bool readSuccess = ReadSensorHTColor(
      COLOR_SENSOR,
      gColorReading.colorNum,
      gColorReading.red,
      gColorReading.green,
      gColorReading.blue
    );
    Wait(MS_20 + MS_5);

    if (readSuccess) {
      gColorReading.readingIsValid = true;
    } else {
      gColorReading.readingIsValid = false;
    }
  }

  gColorReading.readingIsValid = false;
}


/**
 *  This method includes logic that must be tailored to the particular
 *  sensor it is used with. This is to weed out garbage readings.
 */
bool readingIsValid(const ColorVal& pColorVal) {
  if (pColorVal.colorNum == 4) {
     if (pColorVal.red >= 5) {
         return false;
     }
  }
  
  return true;
}


void debugOutputColor(const ColorVal& pColorVal) {
  ClearScreen();
  TextOut(1, LCD_LINE1, "Color Reading:");
  NumOut(2, LCD_LINE2, pColorVal.colorNum);
  NumOut(4, LCD_LINE3, pColorVal.red);
  NumOut(4, LCD_LINE4, pColorVal.green);
  NumOut(4, LCD_LINE5, pColorVal.blue);
  Wait(MS_100);
}

#endif //__COLORSENSING_NXC__
