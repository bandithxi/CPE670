#ifndef __LAB04_CONTROLLER_NXC__
#define __LAB04_CONTROLLER_NXC__

#include "Team_1_MovementLib.nxc"
#include "SonarSensing.nxc"
#include "ColorSensing.nxc"
#include "LightSensing.nxc"
#include "SoundSensing.nxc"


/**
 * Configuration constants
 */
#define OBSTACLE_RADIUS 15 // cm(ish)
#define SOUND_PRESENT 40  // units: ???


/**
 * An enumeration of control strategy values.
 */
enum Strategies {
  PROCEED,
  TURN_AND_WAIT,
  U_TURN,
  AT_HOME = 777
};


task main();
task TASK_controller();
void findLine();
void followLine();
void findHome();
void playVictorySong();


/**
 * Creates the thread responsible for initializing the robot.
 */
task main() {
  Precedes(
    TASK_controller,
    TASK_sonarSensing,
    TASK_soundSensing,
    TASK_colorSensing,
    TASK_lightSensing
  );

  gUseSonarSensing = true;
  gUseSoundSensing = true;
  gUseLightSensing = true;
  gUseColorSensing = true;
}


/**
 * Creates a thread that simply makes the robot move until a sensor
 * detects an obstacle. The thread waits until other tasks are
 * finished using the wheel motors before resuming forward movement.
 */
task TASK_controller() {
  findLine();

  followLine();

  findHome();

  StopAllTasks();
}


/**
 *
 */
void findLine() {


}


/**
 *
 */
void followLine() {

}


/**
 *
 */
void findHome() {
  // playFileEx(filename (*.rso), volume (0-4), loop (T/F))

  gUseSoundSensing = true;

  bool notHome = true;

  while (notHome) {
    int strategy = determineHomeFindStrategy();

    switch (strategy) {
      case AT_HOME:
        stopWheels();
        notHome = false;
        playVictorySong();
        break;
      case PROCEED:
        moveSetDistance(FORWARD, 4);
        break;
      case TURN_AND_WAIT:
      default:
        stationaryTurn(RIGHT, TURN_90);
        Wait(MS_250);
        break;
    }

  }

}


int determineHomeFindStrategy() {
  if (gColorReading.value.colorNum == HOME_COLOR) {
    return AT_HOME;
  } else if (gSoundReading.value >= SOUND_PRESENT) {
    return PROCEED;
  } else if (gSonarReading.rightDistance <= OBSTACLE_RADIUS &&
    gSonarReading.leftDistance <= OBSTACLE_RADIUS) {
    return U_TURN;
  } else {
    return TURN_AND_WAIT;
  }
}

/**
 *  Plays a delightful victory tune.
 */
void playVictorySong() {
  for (int i = 0; i < 5; i++) {
    PlayTone(TONE_A4, MS_100);
    Wait(MS_100);
    PlayTone(TONE_B4, MS_100);
    Wait(MS_100);
    PlayTone(TONE_C4, MS_100);
    Wait(MS_100);
    PlayTone(TONE_D4, MS_300);
    Wait(MS_300);
  }
}


#endif //__LAB04_CONTROLLER_NXC__
