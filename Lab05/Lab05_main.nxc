#ifndef __LAB04_CONTROLLER_NXC__
#define __LAB04_CONTROLLER_NXC__

#include "Team_1_MovementLib.nxc"
#include "SonarSensing.nxc"
#include "ColorSensing.nxc"
#include "LightSensing.nxc"
#include "SoundSensing.nxc"


typedef struct {
  bool rightLightIsOnLine;
  bool leftLightIsOnLine;
  bool colorReadingIsLine;
} LineFollowingState;

/**
 * Configuration constants
 */
#define OBSTACLE_RADIUS 15 // cm(ish)
#define SOUND_PRESENT 40  // units: ???
#define LIGHT_THRESHOLD 40 // units: ???


/**
 * An enumeration of control strategy values.
 */
enum Strategies {
  PROCEED,
  ON_THE_LINE,
  LINE_ON_RIGHT,
  LINE_ON_LEFT,
  TURN_AND_WAIT,
  U_TURN,
  AT_HOME = 777,  // for funsies!
  FREAK_OUT
};


task main();
task TASK_controller();
void findLine();
int determineLineFindingStrategy();
void followLine();
int determineLineFollowingStrategy();
void findHome();
int determineHomeFindingStrategy();
bool isOnTheLine(int pLightSensorValue);
bool isNotOnTheLine(int pLightSensorValue);
LineFollowingState getCurrentLineFollowingState();
void playVictorySong();


/**
 * Creates the thread responsible for initializing the robot.
 */
task main() {
  Precedes(
    TASK_controller,
    TASK_sonarSensing,
    TASK_soundSensing,
    TASK_colorSensing,
    TASK_lightSensing
  );

  gUseSonarSensing = true;
  gUseSoundSensing = true;
  gUseLightSensing = true;
  gUseColorSensing = true;
}


/**
 * Creates a thread that simply makes the robot move until a sensor
 * detects an obstacle. The thread waits until other tasks are
 * finished using the wheel motors before resuming forward movement.
 */
task TASK_controller() {
  findLine();

  followLine();

  findHome();

  StopAllTasks();
}


/**
 *
 */
void findLine() {
  gUseLightSensing = true;
  gUseColorSensing = true;

  bool notOnLine = true;

  while (notOnLine) {
    int strategy = determineLineFindingStrategy();

    switch (strategy) {
      case ON_THE_LINE:
        notOnLine = false;
        break;
      case LINE_ON_RIGHT:
        setSway(RIGHT);
        break;
      case LINE_ON_LEFT:
        setSway(LEFT);
        break;
      case PROCEED:
      default:
        moveSetDistance(FORWARD, 1);
        break;
    }
  }

  gUseLightSensing = false;
  gUseColorSensing = false;
}


int determineLineFindingStrategy() {
  ColorVal colorVal = gUseColorSensing.value;
  int rightLight = gLightReading.rightSensorValue;
  int leftLight = gLightReading.leftSensorValue;

  if (colorVal.colorNum == LINE_COLOR) {
    return ON_THE_LINE;
  } else if (rightLight > LIGHT_THRESHOLD &&
             colorNum != LINE_COLOR) {
    return LINE_ON_RIGHT;
  } else if (lefttLight > LIGHT_THRESHOLD &&
             colorNum != LINE_COLOR) {
    return LINE_ON_LEFT;
  } else /* the line hasn't been found */ {
    return PROCEED;
  }
}

/**
 *
 */
void followLine() {

  /**
   *  Hopefully, the sensors are not so faulty that we need
   *  to track multiple reading states to improve perception
   *  of the current state.
   */

  gUseColorSensing = true;
  gUseLightSensing = true;

  while (gColorReading.value.colorNum != END_OF_LINE_COLOR) {
    int strategy = determineLineFollowingStrategy();

    switch (strategy) {
      case LINE_ON_RIGHT:
        setSway(RIGHT)
        break;
      case LINE_ON_LEFT:
        setSway(LEFT);
        break;
      case FREAK_OUT:
        // currently does nothing
        break;
      case PROCEED:
      default:
        moveSetDistance(FORWARD, 1);
        break;
    }
  }

  gUseLightSensing = false;
  gUseColorSensing = false;
}


int determineLineFollowingStrategy() {
  LineFollowingState state = getCurrentLineFollowingState();

  if (!state.rightLightIsOnLine &&
      state.colorReadingIsLine &&
      !state.leftLightIsOnLine) {
    return PROCEED;
  } else if (state.rightLightIsOnLine) {
    return LINE_ON_RIGHT;
  } else if (state.leftLightIsOnLine) {
    return LINE_ON_LEFT;
  } else /* An error likely occurred */ {
    // do nothing until we figure out how to handle this
    return FREAK_OUT;
  }
}


/**
 *
 */
void findHome() {
  // playFileEx(filename (*.rso), volume (0-4), loop (T/F))

  gUseSoundSensing = true;

  bool notHome = true;

  while (notHome) {
    int strategy = determineHomeFindingStrategy();

    switch (strategy) {
      case AT_HOME:
        stopWheels();
        notHome = false;
        playVictorySong();
        break;
      case PROCEED:
        moveSetDistance(FORWARD, 4);
        break;
      case TURN_AND_WAIT:
      default:
        stationaryTurn(RIGHT, TURN_90);
        Wait(MS_250);
        break;
    }

  }

}


int determineHomeFindingStrategy() {
  if (gColorReading.value.colorNum == HOME_COLOR) {
    return AT_HOME;
  } else if (gSoundReading.value >= SOUND_PRESENT) {
    return PROCEED;
  } else if (gSonarReading.rightDistance <= OBSTACLE_RADIUS &&
    gSonarReading.leftDistance <= OBSTACLE_RADIUS) {
    return U_TURN;
  } else {
    return TURN_AND_WAIT;
  }
}


bool isOnTheLine(int pLightSensorValue) {
  return pLightSensorValue > LIGHT_THRESHOLD;
}


bool isNotOnTheLine(int pLightSensorValue) {
  return !isOnTheLine(pLightSensorValue);
}


LineFollowingState getCurrentLineFollowingState() {
  LineFollowingState currentState;
  currentState.rightLightIsOnLine = isOnTheLine(gLightReading.rightSensorValue);
  currentState.leftLightIsOnLine = isOnTheLine(gLightReading.leftSensorValue);
  currentState.colorReadingIsLine = gColorReading.value.colorNum == LINE_COLOR;

  return currentState;
}


/**
 *  Plays a delightful victory tune.
 */
void playVictorySong() {
  for (int i = 0; i < 5; i++) {
    PlayTone(TONE_A4, MS_100);
    Wait(MS_100);
    PlayTone(TONE_B4, MS_100);
    Wait(MS_100);
    PlayTone(TONE_C4, MS_100);
    Wait(MS_100);
    PlayTone(TONE_D4, MS_300);
    Wait(MS_300);
  }
}


#endif //__LAB04_CONTROLLER_NXC__
