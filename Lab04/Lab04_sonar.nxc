#ifndef __LAB04_SONAR_NXC__
#define __LAB04_SONAR_NXC__


#define RIGHT_SONAR IN_2
#define LEFT_SONAR IN_1

#define NEAR_THRESHOLD 17 // in cm (ish)

#define OBJECT_ON_RIGHT 0
#define OBJECT_ON_LEFT 1
#define NO_OBJECT 255


mutex gSonarMutex;
bool gObstacleOnRight = false;
bool gObstacleOnLeft = false;


task TASK_sonarSensor();
byte readSonarSensor(byte pSensorPort);

/**
 * Creates a thread that will be responsible for detecting when the
 * touch sensors are activated and determining the appropriate
 * avoidance strategy.
 */
task TASK_sonarSensor() {
    // start with sensors de-activated for good measure
    I2CWrite(RIGHT_SONAR, 0x41, 0x00);
    I2CWrite(LEFT_SONAR, 0x41, 0x00);
     
    while (true) {
      byte rightReading = readSonarSensor(RIGHT_SONAR);
      byte leftReading = readSonarSensor(LEFT_SONAR);

      Acquire(gSonarMutex);
      gObstacleOnRight = rightReading <= NEAR_THRESHOLD;
      gObstacleOnLeft = leftReading <= NEAR_THRESHOLD;
      Release(gSonarMutex);
      
/*      ClearScreen();
      if (gObstacleOnRight) {
         TextOut(2, LCD_LINE2, "OBSTACLE ON RIGHT!");
      } else {
        NumOut(2, LCD_LINE2, rightReading);
      }
      if (gObstacleOnLeft) {
         TextOut(2, LCD_LINE4, "OBSTACLE ON LEFT!");
     } else {
        NumOut(2, LCD_LINE4, leftReading);
      }
      Wait(MS_100);
    }
*/
}


byte readSonarSensor(byte pSensorPort) {
  I2CWrite(pSensorPort, 0x41, 0x00);
  I2CWrite(RIGHT_SONAR, 0x41, 0x03);

  byte reading = SensorUS(pSensorPort);
  Wait(MS_50);
  
  I2CWrite(RIGHT_SONAR, 0x41, 0x00);

  return reading;
}

#endif //__LAB04_SONAR_NXC__
