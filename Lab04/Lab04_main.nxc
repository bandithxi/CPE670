#ifndef __LAB04_CONTROLLER_NXC__
#define __LAB04_CONTROLLER_NXC__

#include "Team_1_MovementLib.nxc"
#include "Lab04_sonar.nxc"
#include "Lab04_rfid.nxc"
#include "Lab04_color.nxc"

/**
 * An enumeration of control strategy values.
 */
enum Strategies {
  NO_STRATEGY,
  PROCEED,
  HARD_RIGHT,
  HARD_LEFT,
  SOFT_RIGHT,
  SOFT_LEFT,
  BACK_AWAY,
  U_TURN,
  AT_HOME = 777
};


/**
 * These mutexes are used to prevent ciritical section violations.
 * They ensure that only one task has access to the wheels at a time,
 * and that only one task is reading or writing to the avoidance
 * strategy variable.
 */
mutex gScoreMutex;

/**
 * Global variables to allow for inter-process communication for determining
 * which strategies to use.
 */

 bool gGoHome = false;


task main();
task TASK_waitForHome();
task TASK_controller();
void gatherFood();
int determineGatheringStrategy();
void goHome();
int determineHomeFindingStrategy();
void playVictorySong();


/**
 * Creates the thread responsible for initializing the robot.
 */
task main() {
     Precedes(
              TASK_controller,
              TASK_sonarSensor,
              TASK_rfidSensor,
              TASK_colorSensor,
              TASK_waitForHome
     );

     SetSensorUltrasonic(RIGHT_SONAR);
     SetSensorUltrasonic(LEFT_SONAR);
     SetSensorLowspeed(RFID_SENSOR);
     SetSensorLowspeed(COLOR_SENSOR);
}


task TASK_waitForHome() {
  Acquire(gScoreMutex);
  gGoHome = false;
  Release(gScoreMutex);
  Wait(MIN_1);
  Acquire(gScoreMutex);
  gGoHome = true;
  Release(gScoreMutex);
}


/**
 * Creates a thread that simply makes the robot move until a sensor
 * detects an obstacle. The thread waits until other tasks are
 * finished using the wheel motors before resuming forward movement.
 */
task TASK_controller() {
  Acquire(gScoreMutex);
  while (!gGoHome) {
    Release(gScoreMutex);
    gatherFood();
    Acquire(gScoreMutex);
  }

  goHome();
}


void gatherFood() {
  int strategy = determineGatheringStrategy();
  
  switch (strategy) {
    case HARD_RIGHT:
      hardTurn(RIGHT, TURN_45);
      break;
    case HARD_LEFT:
      hardTurn(LEFT, TURN_45);
      break;
    case BACK_AWAY:
      stopWheels();
      setWheelMotion(REVERSE);
      Wait(SEC_1);
      stationaryTurn(RIGHT, TURN_90 + TURN_45);
      break;
    case SOFT_RIGHT:
      setSway(RIGHT);
      Wait(MS_200);
      break;
    case SOFT_LEFT:
      setSway(LEFT);
      Wait(MS_200);
      break;
    case PROCEED:
    default:
      setWheelMotion(FORWARD);
      Wait(MS_50);
      break;
  }
}


int determineGatheringStrategy() {
  int strategy = NO_STRATEGY;
  
  Acquire(gSonarMutex);
  if (gObstacleOnRight || gObstacleOnLeft) {
    if (!gObstacleOnRight) {
      strategy = HARD_RIGHT;
    } else if (!gObstacleOnLeft) {
      strategy = HARD_LEFT;
    } else {
      strategy = BACK_AWAY;
    }
  }
  Release(gSonarMutex);

  if (strategy != NO_STRATEGY) {
    return strategy;
  }

  int randomNumber = Random(3);
  switch (randomNumber) {
    case 0:
      strategy = SOFT_RIGHT;
      break;
    case 1:
      strategy = SOFT_LEFT;
      break;
    case 2:
    default:
      strategy = PROCEED;
      break;
  }

  return strategy;
}

void goHome() {
  bool atHome = false;

  while (!atHome) {
    int strategy = determineHomeFindingStrategy();
    
    switch (strategy) {
      case AT_HOME:
        atHome = true;
        break;
      case HARD_RIGHT:
        hardTurn(RIGHT, TURN_45);
        break;
      case HARD_LEFT:
        hardTurn(LEFT, TURN_45);
        break;
      case BACK_AWAY:
        stopWheels();
        setWheelMotion(REVERSE);
        Wait(SEC_1);
        stationaryTurn(RIGHT, TURN_90);
        break;
      case PROCEED:
      default:
        setWheelMotion(FORWARD);
        break;
    }
  }

  stopWheels();

  playVictorySong();
}


int determineHomeFindingStrategy() {
  int strategy = PROCEED;

  Acquire(gSonarMutex);
  if (gObstacleOnRight || gObstacleOnLeft) {
    if (!gObstacleOnRight) {
      strategy = HARD_RIGHT;
    } else if (!gObstacleOnLeft) {
      strategy = HARD_LEFT;
    } else {
      strategy = BACK_AWAY;
    }
  }
  Release(gSonarMutex);
  
  if (strategy != PROCEED) {
    return strategy;
  }
  
  Acquire(gColorMutex);
  if (gColorReading.colorNum == HOME_BLACK) {
    strategy = AT_HOME;
  }
  Release(gColorMutex);
  
  return strategy;
}


void playVictorySong() {
  for (int i = 0; i < 5; i++) {
    PlayTone(TONE_A4, MS_100);
    Wait(MS_100);
    PlayTone(TONE_B4, MS_100);
    Wait(MS_100);
    PlayTone(TONE_C4, MS_100);
    Wait(MS_100);
    PlayTone(TONE_D4, MS_300);
    Wait(MS_300);
  }
}


#endif //__LAB04_CONTROLLER_NXC__
