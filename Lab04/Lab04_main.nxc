#ifndef __LAB04_CONTROLLER_NXC__
#define __LAB04_CONTROLLER_NXC__


/**
 * An enumeration of control strategy values.
 */
#define PROCEED 0
#define ENDZONE 1
#define TURN_RIGHT 2
#define TURN_LEFT 3
#define COMPLETE_TURN 4

#define GATHER 0
#define EGRESS 1


/**
 * These mutexes are used to prevent ciritical section violations.
 * They ensure that only one task has access to the wheels at a time,
 * and that only one task is reading or writing to the avoidance
 * strategy variable.
 */
mutex gStrategyMutex;   // wasn't sure how atomic operations can be with NXC
mutex gScoreMutex;

/**
 * Global variables to allow for inter-process communication for determining
 * which strategies to use.
 */
int gStrategy = PROCEED;
int gSeekMode = false;
int gFoodCount = 0;



task main();
task TASK_controller();
void gatherFood();
void goHome();
void playVictorySong();


/**
 * Creates the thread responsible for initializing the robot.
 */
task main() {
     Precedes(
              TASK_controller,
              TASK_sonarSensor,
              TASK_rfidSensor,
              TASK_colorSensor
     );

     SetSensorUltrasonic(RIGHT_SONAR);
     SetSensorLowspeed(RFID_SENSOR);
     SetSensorLowspeed(COLOR_SENSOR);
}


/**
 * Creates a thread that simply makes the robot move until a sensor
 * detects an obstacle. The thread waits until other tasks are
 * finished using the wheel motors before resuming forward movement.
 */
task TASK_controller() {
  while (!timeToGoHome) {
    gatherFood();
  }

  goHome();
}


void gatherFood() {

}


void goHome() {
  bool atHome = false;

  while (!atHome) {
    Acquire(gColorMutex);



    Release(gColorMutex);
  }

  stopWheels();

  playVictorySong();
}




void playVictorySong() {
  PlayTone(TONE_A4, MS_100);
  PlayTone(TONE_B4, MS_100);
  PlayTone(TONE_C4, MS_100);
  PlayTone(TONE_D4, MS_500);
}








#endif //__LAB04_CONTROLLER_NXC__