#ifndef __LAB04_CONTROLLER_NXC__
#define __LAB04_CONTROLLER_NXC__


/**
 * An enumeration of control strategy values.
 */
#define PROCEED 0
#define ENDZONE 1
#define TURN_RIGHT 2
#define TURN_LEFT 3
#define COMPLETE_TURN 4

#define GATHER 0
#define EGRESS 1


/**
 * These mutexes are used to prevent ciritical section violations.
 * They ensure that only one task has access to the wheels at a time,
 * and that only one task is reading or writing to the avoidance
 * strategy variable.
 */
mutex gStrategyMutex;   // wasn't sure how atomic operations can be with NXC
mutex gScoreMutex;

/**
 * Global variables to allow for inter-process communication for determining
 * which strategies to use.
 */
int gStrategy = PROCEED;
int gSeekMode = false;
int gFoodCount = 0;



task main();
task TASK_controller();
void gatherFood();
void goHome();


/**
 * Creates the thread responsible for initializing the robot.
 */
task main() {
     Precedes(
              TASK_controller,
              TASK_sonarSensor,
              TASK_rfidSensor,
              TASK_colorSensor
     );

     SetSensorUltrasonic(RIGHT_SONAR);
     SetSensorLowspeed(RFID_SENSOR);
     SetSensorLowspeed(COLOR_SENSOR);
}



void gatherFood() {
  int turnMagnitude = 
}

void goHome() {
  
}


/**
 * Creates a thread that simply makes the robot move until a sensor
 * detects an obstacle. The thread waits until other tasks are
 * finished using the wheel motors before resuming forward movement.
 */
task TASK_controller() {
  while (!timeToGoHome) {
    gatherFood();
  }

  goHome();
}









#endif //__LAB04_CONTROLLER_NXC__